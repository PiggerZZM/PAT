# PAT_A1103

考点：DFS、打表

难度：中等

DFS分析：

1. 分岔口：每个数字i选或不选
2. 返回条件：处理完所有1到n的数、选择的数已经有k个
3. 目标条件：p次方和等于x
4. 多方案时最优判断：底数和最大、因子组成的序列要按照逆字典序优先
5. 每个数可以重复选择

算法步骤：
1. 读入n、k、p
2. 预处理p次方数组``fac[]``(打表)：令i遍历0到n，如果i的p次方不超过n，则存进``fac[]``，一旦超过则终止遍历。从这里可以得到可能的最大因子``maxi``
3. 用一个``temp[]``数组作为工作变量，记录每一轮递归选中的因子。再用一个``ans[]``数组记录搜索过程中碰到的满足条件的因子。让DFS从最大因子``maxi``开始搜索。
4. 根据``ans[]``的情况输出

DFS的设计：

每次递归都要根据当前所选因子的p次方和以及当前所选因子的个数来进行决策，因此必须要有的三个参数是：当前所处理的因子``i``，当前所选因子的p次方和``psum``，当前所选因子的个数``nowk``。多方案判断中要求底数和最大，因此需要记录当前的底数和``sum``。多方案判断还要求逆字典序优先，因此应该从大的因子开始搜索。因此可以得到DFS的函数原型为：

    void DFS(int i, int psum, int nowk, int sum);

接下来就是分叉路口和返回条件的设计：

1. 返回条件：当前因子到了0的时候就是整个DFS搜索结束的地方，当前所选中因子的个数达到k同样需要停止本轮递归返回
2. 分叉路口：处理因子i时有两种决策，选择i和不选择i。选择i的时候应当根据psum+i^p是否超过n来判断是否进入该分支，即是否需要剪枝(也可以将此条件作为其中一条返回条件来实现，算法笔记上的代码就是将其作为返回条件)

注意点：
1. 如果不打表而是直接在DFS搜索过程中计算i^p，会有很多计算冗余导致超时
2. 剪枝的方法有两个：进入分支之前先判断、直接将其作为返回条件(具体可见DFS_example中DFS函数的后两种实现)
