# PAT_A1034

考点：图的DFS、(并查集)

难度：偏难

数据：
1. ``weight[maxn]``数组存放每个顶点的点权
2. 邻接矩阵``G[maxn][maxn]``存放无向图
3. bool型``vis[maxn]``数组辅助DFS遍历，记录顶点是否被访问过
4. ``map<int, string> intToString`` 编号->姓名，输出时用
5. ``map<string, int> stringToint`` 姓名->编号，输入时用
6. ``map<string, int> Gang``  head->人数，记录每个团伙的头目编号以及人数(因为map自动按照key1升序排列，方便题目要求按照字典序输出)

算法步骤:
1. 读入边数``n``和阈值``k``
2. 读入每条边的端点名和权值，在``stringToint``里查找两个顶点的编号，如果查不到则增加一条记录，在邻接矩阵里记录权值(此处存储为无向图，读到此边的反向边时只需更新权值)
3. DFS遍历无向图，在遍历的过程中计算每个连通分量的人数``numMember``、求出头目的编号``head``、求出该团伙的权值总和``totalvalue``，根据阈值``k``和人数来确定这个连通分量是否是一个团伙，然后将头目和人数记录到``Gang``里
4. 输出团伙数和``Gang``里的记录

DFS的设计：
DFS的任务是计算连通分量人数``numMember``，求出头目编号``head``，求出团伙权值总和``totalvalue``，因此DFS的函数原型应当包括这些参数

    void DFS(int nowvisit, int& numMember, int& head, int& totalvalue);

注意点：
1. 权值总和的计算：DFS的过程仅仅是遍历所有顶点，DFS遍历树一定只是一个真子图，有未遍历到的边。求团伙权值总和实际上是要求DFS过程中把图里的所有边都遍历到，并且将其权值都加起来。为了达到这个目的，必须在DFS遍历每一个点的时候，无论它的邻接顶点是否已经被访问过，都需要检查所有的邻边，但这样会导致有些边的权值被计算了两次(有环的情况下)。处理的方法是统计完一条邻边之后，将其权值和反向边的权值设为0，这样就保证权值只被加了一次。
2. 通话记录最多1000条，意味着顶点数最多是2000.
